;************************************************************************
;	LBAをCHSに変換
;------------------------------------------------------------------------
;	事前にデバイスパラメータを取得しておく
;========================================================================
;■書式		: void lba_chs(drive, drv_chs, lba);
;
;■引数
;	drive	: drive構造体のアドレス
;			:（ドライブパラメータが格納されている）
;	drv_chs	: drive構造体のアドレス
;			:（変換後のシリンダ番号、ヘッド番号そしてセクタ番号を保存する）
;	lba		: LBA
;
;■戻り値	: 成功(0以外)、失敗(0)
;************************************************************************
lba_chs:
		;---------------------------------------
		; 【スタックフレームの構築】
		;---------------------------------------
												; ------|--------
												;    + 8| LBA（2バイト）
												;    + 6| drv_chsドライブ情報
												;    + 4| driveドライブ情報
												; ------+--------
												;    + 2| IP（戻り番地）
		push	bp								;  BP+ 0| BP（元の値）
		mov		bp, sp							; ------+--------

		;---------------------------------------
		; 【レジスタの保存】
		;---------------------------------------
		push	ax
		push	bx
		push	dx
		push	si
		push	di

		;---------------------------------------
		; 【処理の開始】
		;---------------------------------------
		mov		si, [bp + 4]					; SI  = driveバッファ;
		mov		di, [bp + 6]					; DI  = drv_chsバッファ;

		; シリンダあたりのセクタ数を計算（ヘッド数×セクタ数）
		mov		al,  [si + drive.head]			; AL = 最大ヘッド数;
		mul		byte [si + drive.sect]			; AX = 最大ヘッド数 * 最大セクタ数;
		mov		bx, ax							; BX = シリンダあたりのセクタ数;

		; シリンダ番号を取得するために
		; LBAをシリンダあたりのセクタ数で除算
		mov		dx, 0							; DX = LBA（上位2バイト）
		mov		ax,  [bp + 8]					; AX = LBA（下位2バイト）
		div		bx								; DX = DX:AX % BX; // 残り
												; AX = DX:AX / BX; // シリンダ番号

		mov		[di + drive.cyln], ax			; drv_chs.cyln = シリンダ番号;

		; ヘッド位置を取得するために
		; あまりをトラックあたりのセクタ数で除算
		mov		ax, dx							; AX = 残り
		div		byte [si + drive.sect]			; AH = AX % 最大セクタ数; // セクタ番号
												; AL = AX / 最大セクタ数; // ヘッド番号

		movzx	dx, ah							; DX = セクタ番号
		inc		dx								; （セクタは1始まりなので+1）

		mov		ah, 0x00						; AX = ヘッド位置

		mov		[di + drive.head], ax			; drv_chs.head = ヘッド番号;
		mov		[di + drive.sect], dx			; drv_chs.sect = セクタ番号;

		;---------------------------------------
		; 【レジスタの復帰】
		;---------------------------------------
		pop		di
		pop		si
		pop		dx
		pop		bx
		pop		ax

		;---------------------------------------
		; 【スタックフレームの破棄】
		;---------------------------------------
		mov		sp, bp
		pop		bp

		ret

