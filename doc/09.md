## 9-1 アセンブルの手順

- ソースファイル ... アセンブラによってアセンブルされるプログラム
- リスティングファイル ... [-l]をつけてアセンブルすると作成される。ソースファイルがどのように機械語に翻訳されるかを見ることができる
- ラベル
    - ローカルラベル .... 直前に指定されたラベルの範囲内でのみ利用可能なラベル
    - グローバルラベル ... 「.」で開始しないラベル。重複した名前はつけられない。
- 基数
    - プレフィックスかサフィックスで指定することができる
    - 基数がない場合はNASMでは10進数として扱われる
    - 2 B 8 O 10 D 16 X or H

## 9-2 疑似命令とその使用例

- データ定義
    - DB/DW/DD/DQ
    - Byte (1), Word(2), Double Word(4), Quad Word(8)
    - 行の先頭に定義する

    ```c
    db 'hello', 0x0D, 10
    ```

    - 行番号・ロケーションカウンタ・機械語・ソースファイルでlstが出力される
- データ境界(ALIGN)

    ```c
    			db  '*'
    ALIGN 4　# 16ビットデータを4バイト境界に配置する。4つ間隔が空く
    mem:  dw  0x1234 # 16ビットデータ
    ```

- 定数定義(EQU)
    - equ命令は擬似命令は定数を文字列で置き換える
    - 複数箇所で参照される定数を一箇所で定義することができる

```c
message:    db    'hello', 0
msg_len     equ   $ - message # この定数をmsg_lenで置き換える
					  db    msg_len     # 6バイト(hello+改行)確保される
```

- 繰り返し
    - TIMES 指定された回数分後続の命令を繰り返す

    ```c
    times 8 db '*' # *を8回繰り返す
    ```

- ロードアドレス指定(ORG)
    - ディレクティブ ... アセンブラの動作に影響を与える命令のこと。ORGディレクティブとして区別される

    ```c
    # 命令が配置されたアドレスをAXレジスタに設定するもの
    mov    ax, $

    → ロードアドレスの指定をしていないためプログラムは0番地に配置される
    ```

    今回のブートプログラムはアドレスのox7c00にロードされるのでその事実をアセンブラに知らせる必要がある(p256)

    ```c
    ORG    0x7C00
    mov    ax, $
    →　これで0x7C00に配置されるはずだが、機械語では[0000]と出る
    ```

    ロケーションカウンタは暫定値でセクションの配置が終了したときに配置されるアドレスが確定する。生成されたバイナリファイルではちゃんと0x7C00に配置されている。

    mov命令の機械語がB8だから最初はB8

- セクション
    - コンピュータが電源を入れる > ROMのプログラムが動く > RAMでデータの書き込み
        - ROMは電断状態でも値を保持することができる
        - RAM 書き換えがいる
    - セクション ... プログラムの分類。CPU命令が含まれるコード部、定数部、書き換え可能なデータ部に分けられる
    - 9-1の例は.dataと.textを交互に配置している
        - しかし、アセンブルすると[.text]が先頭に、[.data]が後ろにくる
    - ロケーションカウンタ

        $$ ... セクションの開始位置
        $   ... セクションの先頭からのオフセット(ロケーションカウンタ)

- ブートフラグの設定
    - ブートプログラム
        - BIOSによりロードされる512バイトのプログラム
        - BIOSのロード条件に先頭から510バイトの位置に0x55と0xAAが必要(ブートフラグ)
        - そのため残りの部分を任意のデータで埋めた後にブートフラグを定義する

    ```c
    times 510 - ($ - $$) db 0
    db 0x55, 0xAA
    ```

## 9-3 プリプロセッサとその使用例

プリプロセッサ ... アセンブルする前の前処理。全てのプリプロセッサディレクティブは「％」で始まる

- 置き換え(%define)

    ```c
    % difine VALUE 3
    ```

    みたいな感じで、VALUE=3が代入される

- 繰り返し(%rep)

    ```c
    % rep 3
    		db 0
    % endrep
    ```

    繰り返しが3回行われる

- プリプロセッサ変数(%assign)

    プリプロセッサ中のみ有効な変数を定義する。ローカル変数みたいなイメージ

    ```c
    % assign i 3 // int i = 3
    % rep 3 // for 3回
    		db i
    		% assign i i+3 // i += 3
    % endrep
    ```

- 条件付アセンブル (%if)

    条件が成立した時だけアセンブルを行う

    ```c
    % if 1
    		db 'A'
    % else
    		db 'B'
    % endif
    ```

- 繰り返し終了(%exitrep)
    - プログラミングのbreakと同じような働き
- 複数行マクロ(%macro)

    ```c
    %macro   sum  2 // <マクロ名> <引数の数>
             mov       ax, 0 // ax = 0
    				 add       ax, %1 // ax += <一番目の引数>
    				 add       ax, %2 // ax += <二番目の引数>
    %endmacro

    				 sum bx, cx
    ```

- マクロ内ローカルラベル

    「％％<ラベル名>」でマクロの中でラベルを設定することができる

- 可変引数

    マクロの引数を可変にすることもできる。「1-*」で一つ以上の引数になる。

    実際に渡された引数の数は%0で確認することができる。

    インデックスの%1は一番目の引数を、%-1は最後の引数を示す

- 引数の回転(%rotation)
    - 「％rotation 1」や「%rotation -1」で引数の位置が変わる
    - これを使うとC言語の関数呼び出しと同等の処理を行うマクロ「cdecl」を作ることができる
        - stackに引数をpushしていく
        - p269にもっと書いてある
- リスト出力の抑止(.nolist)
    - マクロのリスト出力をしないようにする
        - リスト出力はアセンブルした時にコードの下にできる出力

        ```c
        % macro cdecl 1-*.nolist // <マクロ定義> <関数名> <引数>.nolist
        ```

- ファイルの取り込み(%include)

    ```c
    %include "macro.s"
    ```

    とかするとCの#includeみたいな感じでファイルの展開をすることができる

- 構造体(struc)

    ```c
    struc pos
         .x:          resd      1; // x座標
         .y:          resd      1; // y座標
         .color:      resw      3; // 色
    endstruc
    ```

    データ型

    ```c
    - resb     1バイト
    - resw     2バイト
    - resd     4バイト
    - resq     8バイト
    ```
