## 15 プロテクトモードへの移行
- リアルモードとプロテクトモードの大きな違い -> メモリ空間が保護されているか否か
    - プロテクトモードの全てのタスクが許可されたメモリ空間にいる必要がある
    - アクセス可能なメモリ空間を事前に設定しておく
- メモリ空間の保護
    - アクセスタイプによる保護
    - 特権レベルによる保護
- メモリ空間はセグメントディスクリプタで定義するz

## 16 プロテクトモードで画面出力する
- 画面出力はVRAM領域にデータを書き込む
    - 文字の描画はBIOSのフォントデータを用いて行う
    - 書き込む場所計算する必要がある(めんどくさいw)
- プレーン(白、赤緑青の光る板を制御するやつ)は読み込みプレーンと書き込みプレーンが存在する
プレーンの制御方法
```
mov     ah, 0x01        // プレーン選択
mov     al, 0x04        // 読み込みマップレジスタ(書き込みだったら0x02)
mov     dx, 0x03CE      // グラフィックス制御ポート(書き込みだったらシーケンサ制御ポート0x03C4を選択)
out     dx, ax          // ポート出力
```
- 文字と背景はandとかor演算をとって表示させる
- カラーバーは空白を表示させて背景色のみ表示する
- 線の描画
    - 点の描画の繰り返し
    - 傾斜で描画していく
    - 3/5のような斜めの線は増分を越えたがどうかで書く位置を決める

# 18 プロテクトモードでの割り込みを実現する
- 割り込み ... プログラムカウンタのレジスタの値を変更すること
    - ソフトウェア割り込み ... INT命令またはCPU内部でイベントが検出された時に発生する。無効にはできない。
    - ハードウェア割り込み ... CPUに接続された周辺機器から生成され、CPU命令により割り込みの発生、有効・無効を切り替えることができる
- 割り込みのメモリ空間はカーネルと同様にセグメントディスクリプタで定義する

## 18-1
- 割り込みは他の処理を優先して行う
- interrupt.sは呼び出し元に戻ることがないためレジスタの保存処理を行なっていない
- エラーコードがスタックされる

# 18-5
割り込み許可フラグを操作して割り込みを行う
## PIC(割り込みコントローラ)の初期化
マスターPICとスレーブPICがいる
- 割り込みコントローラを初期化 -> 個別の割り込みを作成 -> 必要な割り込みを有効

## RTC割り込み
- ポーリングを使用して実装していた
- ポーリングをすると一秒に数十回のポートアクセスが発生することになる
-> 大半が無駄なアクセスになる
- そのためデータ取得の割り込みタイミングをRTCからの割り込みで行うように設定する
    - 無駄なポートアクセスが不要になる
- ずっと表示がうまくいかなかったんだけどinit_intのせいでだめだったぽい

## キーボード割り込みを実装する
- RTCと一緒でキーボードも割り込みで実行すべき
- 手順
    - 割り込み処置の作成
    - 割り込み処理の登録
    - KBCの割り込み設定
    - PICの割り込みマスク設定
    - CPUの割り込み許可

- データはリングバッファに保存する
    - リングバッファ？？
    - 書き込み位置と読み込み位置により保存されたデータを管理するもの

ハマってた謎のエラー
- `int_keyboard`の`pusha`を`popa`にしてたせい
- `int_timer`の`pusha`を`popa`にしてたせい

# 19マルチタスク
## 19-1
- とりあえず2つのタスクで動かすようにするTSS(タスクステートセグメント)を2つ用意する
    - TSSはタスクの実行状態を表す
    - コード用とデータ用のセグメントが必要

## 19-3
- 協調型マルチタスク
    - 無限ループ中にjmp命令で2つのタスクを順番に入れ替えていく
    - 問題点: 任意のタスクが長時間CPUを占有することができてしまう
    - いっぱいのタスクを動かすことができない

## 19-4 プリエンプティブ
- 19-3では1つのタスクが占有する事が可能だった
- 割り込み処置ないから他のタスクへ復帰する
- タイマー割り込みで一定周期で切り替えする

# 20 特権状態
## 20-2 コールゲート
- 低い特権レベルからでも呼び出す事ができるカーネル内部の関数を登録する
- ここでcall_gate.sで文字列表示の関数のラッパー関数を作成している

## 20-4 システムコールの実装
- システムコール ... カーネルがタスクに提供するサービスプログラムの集まり
- システムコールの実装
    - ゲート関数の作成
    - ゲート関数の登録
    - 文字列表示関数の修正

## 20-5 同期処理の実現
- 重複呼び出しを禁止してないので複数タスクから同一のシステムコールを呼び出す事が可能になっている
    - 一つのタスクが文字を表示している最中にもタスク切り替えが発生し同じシステムコールを呼び出す事がありえる
    - 文字列表示はVGAポートに連続したアクセスを行なっているがタスク切り替えで異なる文字が設定されると戻った時のタスクではその表示色にならない
- 上記の問題により同期処理の実現が必要
    - テストアンドセットで同期処理を実現する

# 21 小数演算
## 21-1 FPUの動作確認
- FPUを利用して小数演算を行うタスクを作成する
- そのために FPUの初期化処理実装を行う
    - FPUが搭載されていない場合はデバイス利用搭載不可例外を作成する
        - FPUの初期化を行う
        - FPUコンテキストを入れ替える
コード全然わからん。

## 21-2
- 21-1とほぼ一緒のタスク作って実行。反復動作で理解が深まる。良い。

## 21-3
- ばらかく。やる気削がれそう。コピペだ。
- 薔薇を描くタスクの作成
    - タスクの初期化(ローカル変数の初期化)
    - グラフ枠の描画
    - 薔薇曲線の初期化
    - 座標計算
    - 角度更新
    - ドット描画(描画色)
    - ウェイト
    - ドット描画(背景色)
- これ使えばマイメロかけそう

# 22 ページング
- ページング機能は論理アドレスから物理アドレスへのページ変換を行う
- 実際はページディレクトリとページテーブルと呼ばれる2つの情報配列で実装される
- 今回は全てのタスクが共通で使用するページ変換テーブルを作成する

## 22-1
eaxとecx間違えただけで描画されなくなって笑った。レジスタの登録違うと確かになるけれども。厳しい世界。

## 22-2
page-faultのエラーが出ないと思ったら、kernel.sのパディングの設定をbootsizeにしていた...
サイズ的には一緒だけど、アクセスする位置とかそういうのが関係していたのかな。

# 23 コードを共有する
## 23-5
- 描画されない原因
    - memcpyのコードがミスってたからだった。
    - マルチタスクのせいか描画めっちゃ遅い 

# 24 ファイルシステムを利用する
- ブートプログラムからFATにアクセスする
- 32Mバイト以上の記憶容量をもつ外部記憶装置にFAT16を実装する
## 24-1
- BPB（ブートパラメターブロック)を作る必要がある
- boot.sの設定意味わかんなすぎる。BPBの設定だけど呪文

## 24-2
- ディレクトリエントリ
    - ファイル情報的なやつ、拡張し、ファイル名、作成時刻、ファイルサイズなどの情報を持っている
    - 時刻などについては時、分、秒でビットを持っている。
    - 年、月、日も同様

## 24-3
- メディアをフォーマットする
    - BPBに設定した通りの配置でFAT, ルートディレクトリ、データ領域を作成していく


# 25 モード移行
- ファイル読み出しやディスク読み出しのためにBIOSコールが必要
- しかし、プロテクトモードではBIOSの機能を利用する事ができない
- そこでモード移行を実装する

## 25-1
リアルモードへ移行
- 16ビットセグメントディスクリプタの作成
    - 32から16にする
    ```
    .cs_bit16:		dq	0x000F9A000000FFFF			; コードセグメント（16ビットセグメント）
    .ds_bit16:		dq	0x000F92000000FFFF			; データセグメント（16ビットセグメント）
    ```
- 16ビットプロテクトモードに移行

- リアルモードに移行
- ページングの無効化

# 26 ファイル読み出し
- PM -> RM になってもBIOSコールを実行できない
- BIOSが行なった割り込みコントローラの設定を変更したため
## 26-2 ファイル名の検索
- FATのディレクトリエントリに32バイトのファイル情報が書き込まれている
- そのディレクトリエントリとファイル名の比較を繰り返す
- BPBはルートディレクトリのエントリ数を512に設定しているため、32セクタ読み込んでファイル検索を行う

# 27 電源を切る
- 電断処理の実現はシステム状態をS5状態に遷移させるとできるらしい
    - 具体的には固定ACPIディスクリプタテーブルに記載された二つのレジスタにS5状態を示す設定値を書き込む

- 手順
    - 電断契機を検出する
    - FADTからACPIレジスタを取得
    - DSDTからS5に遷移するための設定値を取得
    - ACPIレジスタにシステム状態を表す設定値を書き込む